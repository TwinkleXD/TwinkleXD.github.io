---
title: 浏览器和网络基础
category:
  - [浏览器和网络]
mathjax: true
toc: true
comments: true
date: 2024-04-24 13:50:58
tags:
    - 网络
description: 面试总结的相关网络问题
permalink:
sticky:
---

参考：
[前端必备的HTTP知识](https://mp.weixin.qq.com/s/nq8UKufJ8ncnKPWfYSJX1Q)
[HTTP基础](https://www.cnblogs.com/juno3550/p/14375659.html)

# HTTP
http全称是超文本传输协议，是一种能够获取html、图像等网络资源的通讯协议，是web上进行数据交换的基础。http是一种用于分布式、协作式和超媒体信息系统的应用层协议，它不关心网络通信的具体细节，依赖于面向连接的可靠的TCP进行消息传递。
## 特性
- 简单：header+body的形式，头部信息也是key-value的简单文本格式。
- 可拓展：http协议里的各类请求方法、URL/URI、状态码、headers等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
- 应用广泛、跨平台：web端、移动端app都能应用。
- 无状态：http协议自身不对请求和响应之间的通信状态进行保存，也就是说在同一个连接中，两个执行成功的http请求之间是没有关系的。解决这个问题可以通过cookies，把cookies添加到头部，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。
## http组件系统
包括客户端、web服务器和代理。
## http会话
建立连接 -> 发送客户端请求 -> 服务器响应请求
## http的消息类型
请求和响应（都包含：start line、http headers、empty line、body）
## http方法
安全方法：GET和HEAD方法都被认为是安全的，不会在服务端产生什么结果（不意味着什么动作都没发生）
- GET：请求服务器发送某个资源
- HEAD：跟GET方法类似，但服务器在响应中只返回了首部，不会返回实体的主体部分。
- PUT：向服务器中写入文档。语义：用请求的主体部分来创建一个由所请求的URL命名的新文档。
- POST：用来向服务器中输入数据的，通常提交表单数据给服务器。
- TRACE：主要用于诊断，loop-back测试，提供了一种实用的debug机制
- OPTIONS：请求web服务器告知器支持的各种功能
- DELETE：请求服务器删除请求URL中指定的资源

# 状态码
## 主要列举
- 100~199——信息性状态码
  - 101 Switching Protocol。在HTTP升级为Websocket的时候，如果服务器同意变更，就会发送状态码101
- 200~299——成功状态码
  - 200 OK
  - 204 No content 请求成功，但是报文不含实体的主体部分
  - 205 Reset Content 请求成功，但是报文不含实体的主体部分，要求请求方重置内容
  - 206 Partial Content 进行范围请求
- 300~399——重定向状态码
  - 301 moved permanently 永久性重定向，表示资源已被分配新的URL
  - 302 found 临时性重定向，表示资源临时被分配了新的URL
  - 303 see other 表示资源存在着另一个URL，应使用GET方法获取资源
  - 304 not modified 表示服务器允许访问资源，但因发生请求未满足条件的情况
  - 307 temporary redirect 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
- 400~499——客户端错误状态码
  - 400 bad request 请求报文存在语法错误
  - 401 unauthorized 表示发送的请求需要通过HTTP认证的认证信息
  - 403 forbidden 表示请求资源的访问被服务器拒绝
  - 404 not found 表示在服务器上没有找到请求的资源
- 500~599——服务器错误状态码
  - 500 internal sever error 表示服务器端在执行请求时发生了错误
  - 501 Not Implemented 表示服务器不支持当前请求所需要的某个功能
  - 503 service unavailable 表明服务器暂时处于超负载或正在停机维护，无法处理请求
## 常见的状态码
200，请求成功，返回数据
206，成功执行部分请求
301，永久重定向
302，临时重定向
304，资源未修改，使用缓存
401，需要身份认证
403，请求被拒绝
404，未找到资源
502，无效网关
503，服务不可用
504，请求超时

# http2.0和1.0有什么区别
## HTTP1.1
- 连接可以复用。长连接：connection: keep-alive在一个TCP上可以传送多个请求和响应，减少了建立和关闭连接的消耗和延迟
- 管道化技术（HTTP pipelining）。允许在第一个应答被完全发送完成前就发送第二个请求，以降低通信延迟。复用同一个TCP连接期间，即便是通过管道同时发送了多个请求，服务端也是按请求的顺序依次给出响应；而客户端在未收到之前发出所有请求的响应之前，将会阻塞后面的请求（排队等待），这称为“队头堵塞”（head-of-line blocking）
- 支持响应分块，分块编码传输。产生一块数据就发送一块数据，采用“流模式（Stream）”取代“缓存模式（Buffer）”。Transfer-Encoding: chunked表明body将可能由数量未定的多个数据块组成，每个数据块之前会有一行包含一个16进制数值，表示块的长度，最后一个大小为0，表示本次响应的数据发送完了
- 引入额外的缓存控制机制。
- Host头。不同的域名配置同一个IP地址的服务器。Host是HTTP1.1协议中新增的一个请求头，主要用来实现虚拟主机技术
虚拟主机（virtual hosting）即共享主机（shared web hosting），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。
## HTTP2.0
是二进制协议而不是文本协议。
- 帧：是基于新协议通信的最小单位，客户端与服务端通过交换帧来通信
- 消息：指逻辑上的HTTP消息，比如请求、响应等，有一个帧或者多干帧组成
- 流：是连接中的一个虚拟信道，可以承载双向的消息，每一个流都有唯一的整数标识符
客户端和服务端，可以将HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端把他们重新组装起来。
1. 并行交错地发送多个请求，请求之间互不影响
2. 并行交错地发送多个响应，响应之间互不干扰
3. 使用一个连接并行发送多个请求和响应
4. 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间
5. 不必再为绕过HTTP/1.x限制而做很多工作（比如精灵图）
## 总结
首先http协议可以简单理解成对服务端进行资源数据请求的一种协议。
早期网页内容比较简单，使用http1.0，每次连接只发送一个请求，完成了一个请求和回复，就断开连接，是非持久性的，每次请求开销较大；支持的消息体的数据类型也比较简单，只有text/html；针对这些问题，http1.1做了些改进，其中主要是，增加了长连接，使一个TCP连接可以传送多个请求和响应，只要配置头信息中的connection：keep-alive；增加了host字段，指定对应的虚拟站点；提供了身份认证、状态管理和缓存机制，还有文件的断点续传。
实际上长连接还是不能解决线头阻塞这样的问题，http2.0新增了多路复用，可以看成是长连接的升级版。这里引入了流和帧的概念，帧是数据传输的最小单位，包含序列标识和它所属的流，多个帧就能构成流，一个流也就是一个请求。多路复用就是在一个TCP连接中存在多个流，服务器通过帧的标识知道它属于哪个流，从而还原请求，这样就能允许并发多个请求，每一个请求和响应就不需要互相等待，避免了线头阻塞问题。http2.0的解析采用二进制分帧，对比1.0、1.1的基于文本格式更加健壮。另外还有首部压缩，减少了必要的传输大小；支持服务端推送，减少了重复请求步骤。
总之，http协议的演进可以看作是对日益复杂的请求和响应做的优化，提高通信的性能效率，降低开销。

# http和https的区别
https的s是Secure，是为了解决http传输中的安全性问题。主要区别有：
- http是明文传输，https是经过加密的，更安全
- 使用端口不同，http使用80端口，https使用443
- https需要使用ssl相关的证书，需要付费
实际上，https不是新的应用层协议，只是http不再直接和TCP通信，而是理解成增加了ssl，先让http和ssl通信，ssl和TCP通信

# 输入一次url发生的过程
浏览器首先向DNS服务器发送域名，进行域名解析，获取对应的IP地址，返回给浏览器。浏览器通过TCP三次握手与这个IP的服务器建立连接，然后向这个web服务器发出请求，服务器处理请求并返回响应。浏览器拿到响应文本后，解析html代码，请求js、css等资源，进行页面渲染。数据传输完毕后，经过四次挥手断开TCP连接。

# 缓存
在进建立TCP连接前，会先判断是否命中缓存。缓存有两种，强缓存和协商缓存。
[协商缓存与强缓存](https://www.cnblogs.com/wonyun/p/5524617.html)

# TCP三次握手和四次挥手，以及原因
## 三次握手
- 一开始客户端和服务端都处于关闭状态，CLOSED
- 建立连接的时候，客户端会主动打开，服务端是被动打开并且进入LISTEN状态
- 此时客户端会向服务端发送连接请求报文，此时报文首部信息同步SYN=1，初始化序列号seq=x，客户端进入SYN-SENT同步已发送状态；
- 当服务端收到连接请求报文，如果同意，会发出确认报文，确认ACK=1，同步SYN=1，确认号小ack=x+1，同时自己也会初始化一个序列号seq=y，服务端进入SYN-RCVD（同步收到）状态；
- 客户端收到确认报文后，还需要向服务端发送确认报文，确认ACK=1，小ack=y+1，自己的序列号为seq=x+1，此时连接建立，客户端进入ESTABLISHED（已建立连接）状态；
- 服务器收到确认报文后也进入ESTABLISHED状态，就可以开始通信了
![三次握手示意图](source/_posts/Assert/broandnet/3times.png)

## 三次握手原因
主要是最后一次确认，这个是为了防止已失效的报文又传送到服务器，从而产生错误。
比如客户端发送第一个请求连接，没有丢失，只是在网络中滞留，那当客户端一直没有收到确认报文，会重新发送这条报文去建立连接，等传输完成关闭连接，这时候上一条滞留的请求又到达的服务端，如果不是三次握手，那么会再一次建立连接，这样就可能会出错而且浪费资源；三次握手就会保证即使有这条报文的确认报文传到客户端，但是没有客户端的确认报文传回去，就不会建立这次连接。
## 四次挥手
- 断开连接的时候，两边都先处于ESTABLISHED状态
- 客户端发出连接释放报文，停止传输数据，报文首部，FIN=1，序列号为上一条数据的+1，比如seq=u，客户端进入FIN-WAIT-1状态；
- 服务端收到连接释放报文，发送确认报文，确认ACK=1，确认号小ack=u+1，还有自己的序列号seq=v，客户端进入CLOSE-WAIT状态；
- 此时通信处于半关闭状态，客户端不再发送数据，但是服务端仍然在发送的数据，客户端还需要接受；
- 客户端收到确认请求后会进入FIN-WAIT-2状态，等待服务端发送连接释放报文；
- 服务端数据发送完毕后，向客户端发送连接释放报文，FIN=1，小ack=u+1，自己的序列号由于发送了一些数据，可能为seq=w，此时服务端就进入了LAST-ACK（最后确认）状态；
- 客户端收到连接释放报文后，发出确认，ACK=1，小ack=w+1，seq=u+1，进入TIME-WAIT（时间等待）状态，然后经过2*MSL时间后，才进入CLOSED状态；
- 服务端收到客户端的确认后立即进入CLOSED状态；
- 连接断开
![四次挥手示意图](source/_posts/Assert/broandnet/4times.png)

## 四次挥手中等待2*MSL的原因
MSL为最长报文寿命，原因一个是，保证最后的确认报文能够到达服务端，如果没有到达的话，服务端会再次发送一个连接释放报文，客户的在这个时间段内收到报文能进行再次处理，重新等待2*MSL时间；另一个是和三次握手一样，防止失效连接再次出现，本次连接中产生的报文都会在2*MSL时间内消失。

# TCP和UDP的区别
TCP：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看作字节流，把字节流组织成大小不等的数据块），每一条TCP链接只能是点对点的（一对一）。
UDP：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一，一对多，多对一和多对多的交互通信。

# get/post
GET是无副作用、幂等的；POST是有副作用、不幂等的。
| | GET | POST |
|--|---|---|
| 缓存 | 请求能缓存 | 请求不能缓存 |
| 安全 | 请求在URL中，会被浏览器保存记录 | 放在请求体中 |
| 限制 | URL有长度限制 | |
| 编码 | 只能进行URL编码，只能接受ASCII字符 | 没有限制|
| 报文发送方式 | 请求报文会一次性发出去 | 分为两个TCP数据包，先发header，服务器响应100后发body部分 |

## 总结
本质上get是从服务器获取数据，post是向服务器传送数据。
- get的参数通过拼接到URL上，是可见的，大小由浏览器限制，一般2-4k；post则是通过body传参，URL上不可见，数据大小可以配置
- get请求是可以缓存的，post不可以
- get请求页面后退时不会有影响，post后退时会重新提交请求
- 比较而言，post更安全一点
- get发送数据包，会把header和data一起发送，post会先发送header，返回100continue，才会继续发送data数据，也就是post会产生两个数据包

# 进程和线程的区别

# 五层协议结构及各层协议
- 应用层：HTTP/DNS/FTP
- 传输层：TCP/UDP
- 网络层：IP/ARP
- 链路层：VLAN/MAC
- 物理层

# 安全（XSS攻击、CSRF攻击、DDOS攻击）
## XSS
跨站脚本攻击：网页中插入恶意script代码
[知乎-浅谈XSS攻击](https://zhuanlan.zhihu.com/p/26177815)
## CSRF
跨站请求伪造：盗用身份发送请求
防范：token，验证码
## DDOS
通过大量合法请求占用资源，干扰正常通信
## DHCP协议
局域网的网络协议，基于UDP，自动分配IP给用户，并且可以中央管理
[DHCP百科](https://baike.c114.com.cn/view.asp?id=1435-1C78A4D5)

# Cookies
是服务器发送到用户浏览器并保存在本地的一小块数据，会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- 会话期Cookie：是最简单的Cookie，浏览器关闭后会自动被删除，即仅在会话期内有效
- 持久性Cookie：可以指定特定的过期时间（Expires）或有效期（Max-Age）
- 带有Secure标记：只应通过被HTTPS协议加密过的请求发送给服务端，但敏感信息还是尽量避免通过cookie传输，不能够确保安全
- 带有HttpOnly标记：Document.cookie是无法访问的，为了避免跨域脚本攻击（xss）
cookie的作用域通过Domain和Path指定
SameSite Cookies允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击

# HTTP访问控制（CORS）
跨域资源共享（CORS）是一种机制，使用额外的HTTP头告诉浏览器，让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器的指定的资源

# 代理（Proxy）
在浏览器和服务器之间，有很多计算机和其他设备转发了http消息，它们可能出现在传输层、网络层和物理层上，对于http应用层而言式透明的。有如下的一些作用：
- 缓存
- 过滤（像防病毒扫描、家长控制）
- 负载均衡
- 认证（对不同的资源进行权限控制）
- 日志管理