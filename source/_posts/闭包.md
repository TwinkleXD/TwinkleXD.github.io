---
title: 闭包
category:
  - [JavaScript]
mathjax: true
toc: true
date: 2023-03-01 13:09:29
tags:
  - JavaScript
  - note
description: 有关闭包的总结与理解
permalink:
sticky:
---
参考：
[闭包：什么是闭包 闭包的用途 - 掘金](https://juejin.cn/post/7107545188880351240)

# 函数作用域
一个函数要执行时，会在内存里面创建一个独立作用域。函数中的变量只能在这个独立的作用域里使用。函数执行完毕后，这个独立作用域就会删除。只有一种情况下不会删除，就是 闭包。
# 内存回收机制
内存回收机制就是不再用到的内存空间，系统会自动进行清理出空间给其他程序使用。
回收机制不会对正在引用的变量或者对象进行回收的。因此内部函数引用外部函数的变量，外部函数执行完毕，作用域也不会删除，从而形成了一种不会被删除的独立作用域。
```js
function func(){
  let a = 1 // 独立作用域，不会被删除
  return function(){
    console.log(a) // 内部函数引用外部函数变量
  }
}
```
# 作用继承
即作用域继承，子作用域可以获取父作用域的变量，但是父作用域不能获取子作用域的变量。也就是，内部函数能够访问外部函数的作用域变量，外部函数不能获取内部函数的作用域变量。
# 闭包
在一个函数里面再定义一个函数，这个内部函数一直保持有对外部函数中作用域的访问。函数执行，形成一个独立作用域，保护里边的私有变量不受外界的干扰，还可以存储一些内容。这个模式叫做闭包。
```js
function f1(){
    var n=999;
    nAdd=function(){            // 匿名函数，且没有使用var关键字，是一个全局变量
        console.log(n+=1);  
    }

　　function f2(){
      console.log(n);
    }
return f2;
}

var result=f1()
result()
nAdd()
result()

// 999
// 1000
// 1000
```
result实际上是闭包f2函数，一共运行了两次，一次是999，一次是1000。这证明了函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
原因：f1是f2的父函数，而f2被赋给了一个全局变量，导致f2始终在内存中，而f2依赖于f1，因此f1也始终在内存中，不会在调用结束后被垃圾回收机制回收。
# 闭包的作用
通过一系列方法，将函数内部的变量（局部变量）转化为全局变量。
闭包会在父函数外部改变父函数内部变量的值，所以在把父函数当作对象（object）使用，把闭包当作公共方法（public method），内部变量当作私有属性（private value）时，要注意不能随便改变父函数内部变量的值。
# 优缺点
## 优点
- 保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突
- 在内存中维持一个变量，可以做缓存
- 匿名立即执行函数可以减少内存消耗
## 缺点
- 闭包会使得函数中的变量都被保存在内存中，内存消耗大，所以不能滥用闭包，会造成网页性能问题。
解决方法：在退出函数之前，将不使用的局部变量全部删除。
- 由于闭包涉及跨域访问，所以会导致性能损失。
解决方法：可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。
